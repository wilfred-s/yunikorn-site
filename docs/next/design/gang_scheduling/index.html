<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.63">
<title data-react-helmet="true">Gang scheduling design | Apache YuniKorn (Incubating)</title><meta data-react-helmet="true" name="docsearch:version" content="current"><meta data-react-helmet="true" property="og:image" content="http://yunikorn.apache.org/img/logo/yunikorn-logo-main.png"><meta data-react-helmet="true" property="twitter:image" content="http://yunikorn.apache.org/img/logo/yunikorn-logo-main.png"><meta data-react-helmet="true" name="twitter:image:alt" content="Image for Apache YuniKorn (Incubating)"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:title" content="Gang scheduling design | Apache YuniKorn (Incubating)"><meta data-react-helmet="true" name="description" content="&lt;!--"><meta data-react-helmet="true" property="og:description" content="&lt;!--"><meta data-react-helmet="true" property="og:url" content="http://yunikorn.apache.org/docs/next/design/gang_scheduling"><link data-react-helmet="true" rel="shortcut icon" href="/img/yunikorn.ico"><link data-react-helmet="true" rel="canonical" href="http://yunikorn.apache.org/docs/next/design/gang_scheduling"><link rel="stylesheet" href="/styles.3300edef.css">
<link rel="preload" href="/styles.42927ee7.js" as="script">
<link rel="preload" href="/runtime~main.1daa9f04.js" as="script">
<link rel="preload" href="/main.6222ead5.js" as="script">
<link rel="preload" href="/1.f2f38753.js" as="script">
<link rel="preload" href="/2.05510059.js" as="script">
<link rel="preload" href="/3.a37a1908.js" as="script">
<link rel="preload" href="/1be78505.e1f44db4.js" as="script">
<link rel="preload" href="/146.37105179.js" as="script">
<link rel="preload" href="/935f2afb.0d861f82.js" as="script">
<link rel="preload" href="/17896441.6af894f7.js" as="script">
<link rel="preload" href="/4356428f.e37edb5c.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav class="navbar navbar--light navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><img class="navbar__logo" src="/img/yunikorn.ico" alt="YuniKorn Site Logo"><strong class="navbar__title">Apache YuniKorn</strong></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/">Quick Start</a><a class="navbar__item navbar__link" href="/community/roadmap">Roadmap</a><a class="navbar__item navbar__link" href="/community/download">Download</a><div class="navbar__item dropdown dropdown--hoverable dropdown--left"><a target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Community</a><ul class="dropdown__menu"><li><a class="dropdown__link" position="left" href="/community/get_involved">Get Involved</a></li><li><a class="dropdown__link" position="left" href="/community/how_to_contribute">How to Contribute</a></li><li><a class="dropdown__link" position="left" href="/community/coding_guidelines">Coding Guidelines</a></li><li><a class="dropdown__link" position="left" href="/community/reporting_issues">Reporting Issues</a></li><li><a class="dropdown__link" position="left" href="/community/sessions">Sessions and Demos</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable dropdown--left"><a target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Apache</a><ul class="dropdown__menu"><li><a href="https://www.apache.org/" target="_blank" rel="noopener noreferrer" class="dropdown__link" position="left">Apache Software Foundation</a></li><li><a href="https://incubator.apache.org/" target="_blank" rel="noopener noreferrer" class="dropdown__link" position="left">Apache Incubator</a></li><li><a href="https://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="noopener noreferrer" class="dropdown__link" position="left">Apache License</a></li><li><a href="https://www.apache.org/foundation/sponsorship.html" target="_blank" rel="noopener noreferrer" class="dropdown__link" position="left">Sponsorship</a></li></ul></div></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs">Docs</a><ul class="dropdown__menu"><li><a aria-current="page" class="dropdown__link dropdown__link--active" position="left" href="/docs/next/">Master</a></li><li><a class="dropdown__link" position="left" href="/docs/">0.10.0</a></li><li><a class="dropdown__link" position="left" href="/docs/0.9.0/">0.9.0</a></li><li><a class="dropdown__link" position="left" href="/docs/0.8.0/">0.8.0</a></li></ul></div><a href="https://github.com/apache/incubator-yunikorn-core" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-github-link" aria-label="GitHub repository"></a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2aTZ"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_BsTx">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_BsTx">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img class="navbar__logo" src="/img/yunikorn.ico" alt="YuniKorn Site Logo"><strong class="navbar__title">Apache YuniKorn</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/docs/">Quick Start</a></li><li class="menu__list-item"><a class="menu__link" href="/community/roadmap">Roadmap</a></li><li class="menu__list-item"><a class="menu__link" href="/community/download">Download</a></li><li class="menu__list-item"><a target="_blank" rel="noopener noreferrer" class="menu__link menu__link--sublist">Community</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" position="left" href="/community/get_involved">Get Involved</a></li><li class="menu__list-item"><a class="menu__link" position="left" href="/community/how_to_contribute">How to Contribute</a></li><li class="menu__list-item"><a class="menu__link" position="left" href="/community/coding_guidelines">Coding Guidelines</a></li><li class="menu__list-item"><a class="menu__link" position="left" href="/community/reporting_issues">Reporting Issues</a></li><li class="menu__list-item"><a class="menu__link" position="left" href="/community/sessions">Sessions and Demos</a></li></ul></li><li class="menu__list-item"><a target="_blank" rel="noopener noreferrer" class="menu__link menu__link--sublist">Apache</a><ul class="menu__list"><li class="menu__list-item"><a href="https://www.apache.org/" target="_blank" rel="noopener noreferrer" class="menu__link" position="left">Apache Software Foundation</a></li><li class="menu__list-item"><a href="https://incubator.apache.org/" target="_blank" rel="noopener noreferrer" class="menu__link" position="left">Apache Incubator</a></li><li class="menu__list-item"><a href="https://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="noopener noreferrer" class="menu__link" position="left">Apache License</a></li><li class="menu__list-item"><a href="https://www.apache.org/foundation/sponsorship.html" target="_blank" rel="noopener noreferrer" class="menu__link" position="left">Sponsorship</a></li></ul></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--sublist navbar__link--active" href="/docs">Docs</a><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active" position="left" href="/docs/next/">Master</a></li><li class="menu__list-item"><a class="menu__link" position="left" href="/docs/">0.10.0</a></li><li class="menu__list-item"><a class="menu__link" position="left" href="/docs/0.9.0/">0.9.0</a></li><li class="menu__list-item"><a class="menu__link" position="left" href="/docs/0.8.0/">0.8.0</a></li></ul></li><li class="menu__list-item"><a href="https://github.com/apache/incubator-yunikorn-core" target="_blank" rel="noopener noreferrer" class="menu__link header-github-link" aria-label="GitHub repository"></a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_2gpo"><div class="docSidebarContainer_3_JD" role="complementary"><div class="sidebar_2urC"><div class="menu menu--responsive menu_5FrY"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_Dm3K" xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 32 32" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Get Started</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/next/">Get Started</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/next/get_started/core_features">Features</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">User Guide</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/next/user_guide/queue_config">Partition and Queue Configuration</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/next/user_guide/placement_rules">App Placement Rules</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/next/user_guide/sorting_policies">Sorting Policies</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/next/user_guide/acls">ACLs</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/next/user_guide/resource_quota_management">Resource Quota Management</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/next/user_guide/gang_scheduling">Gang Scheduling</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Workloads</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/next/user_guide/workloads/run_spark">Run Spark Jobs</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/next/user_guide/workloads/run_flink">Run Flink Jobs</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/next/user_guide/workloads/run_tf">Run Tensorflow Jobs</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">REST APIs</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/next/api/cluster">Cluster</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/next/api/scheduler">Scheduler</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/next/api/system">System</a></li></ul></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/next/user_guide/trouble_shooting">Trouble Shooting</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Developer Guide</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/developer_guide/env_setup">Dev Environment Setup</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/developer_guide/build">Build and Run</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/developer_guide/deployment">Deploy to Kubernetes</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/developer_guide/openshift_development">Development in CodeReady Containers</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">Designs</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/design/architecture">Architecture</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/design/scheduler_core_design">Scheduler Core Design</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/design/cache_removal">Scheduler cache removal design</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/design/k8shim">Kubernetes Shim Design</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/design/cross_queue_preemption">Cross Queue Preemption</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/design/namespace_resource_quota">Namespace Resource Quota</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/design/pluggable_app_management">Pluggable App Management</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/design/resilience">Resilience</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/design/predicates">Support K8s Predicates</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/design/scheduler_configuration">Scheduler Configuration</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/design/state_aware_scheduling">Batch Workloads Ordering with StateAware Policy</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/design/scheduler_object_states">Scheduler Object States</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs/next/design/gang_scheduling">Gang scheduling design</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Performance</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/next/performance/evaluate_perf_function_with_kubemark">Evaluate YuniKorn function &amp; performance with Kubemark</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/next/performance/metrics">Scheduler Metrics</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/next/performance/profiling">Profiling</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3EyW"><div class="container padding-vert--lg docItemWrapper_1EkI"><div class="row"><div class="col docItemCol_2ASc"><div class="alert alert--warning margin-bottom--md" role="alert"><div>This is unreleased documentation for Apache YuniKorn (Incubating) <strong>Next</strong> version.</div><div class="margin-top--md">For up-to-date documentation, see the <strong><a href="/docs/">latest version</a></strong> (0.10.0).</div></div><div class="docItemContainer_3QWW"><article><div><span class="badge badge--secondary">Version: Next</span></div><header><h1 class="docTitle_1Lrw">Gang scheduling design</h1></header><div class="markdown"><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="gang-scheduling-implementation"></a>Gang Scheduling Implementation<a aria-hidden="true" tabindex="-1" class="hash-link" href="#gang-scheduling-implementation" title="Direct link to heading">#</a></h1><p>A new way of scheduling applications by taking into account the demand for resources the application expects it will generate over time.
It guarantees the expected demand resources for the application by reserving the resources.</p><p>There are two parts to this implementation:</p><ul><li>Kubernetes Shim</li><li>Core and scheduling</li></ul><p>This document describes the implementation on the core side.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="document-goals"></a>Document goals<a aria-hidden="true" tabindex="-1" class="hash-link" href="#document-goals" title="Direct link to heading">#</a></h2><p>This document describes the following implementation design points:</p><ol><li>Define changes required for the shim to core communication (scheduler interface)</li><li>Scheduler storage object changes</li><li>Scheduler logic changes</li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="excluded-design-points"></a>Excluded design points<a aria-hidden="true" tabindex="-1" class="hash-link" href="#excluded-design-points" title="Direct link to heading">#</a></h2><p>Currently, the Kubernetes shim side implementation is not covered in this design document.</p><p>Generalised preemption on the core side will <em>not</em> be discussed in this design.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="generic-flow"></a>Generic flow<a aria-hidden="true" tabindex="-1" class="hash-link" href="#generic-flow" title="Direct link to heading">#</a></h2><p>The flow is triggered by a pod that is submitted which triggers the application creation.
This first pod is in the case of a Spark application, the driver pod.
In case the flow is triggered from the creation of an application CRD there will not be a first pod.
This is however outside the core scheduling logic. From the core side there should be no difference between the two cases.
More details are in the chapter on the <a href="#scheduler-logic-changes">Scheduler logic changes</a>.</p><p>The flow of an application submitted. The numbers in the diagram correspond to the description below the diagram.</p><p><img alt="generic flow" src="/assets/images/gang_generic_flow-7aa03e3ed0477897b3694adeb9e77253.png"></p><p>Combined flow for the shim and core during startup of an application:</p><ul><li>An application is submitted with TaskGroup(s) defined. (1)</li><li>The shim creates the application and passes the application to the core. (2)</li><li>The shim creates placeholder pods for each of the members of the TaskGroup(s) (3)</li><li>The pods are processed and passed to the core, as per the normal behaviour, as AllocationAsks for the application with the correct info set. (4)</li><li>The placeholder AllocationAsk’s are scheduled by the core as if they were normal AllocationAsk’s. (5)</li><li>All Allocations, even if they are the result of the placeholder AllocationAsks being allocated by the scheduler, are communicated back to the shim.</li><li>The original real pod is passed to the core as an AllocationAsk. (6)</li><li>After the real pod and all all the placeholder pods are scheduled the shim starts the real pod that triggered the application creation. (7)</li></ul><p>After the first, real, pod is started the following pods should all be handled in the same way (8):</p><ul><li>A real pod is created on k8s.</li><li>The pod is processed and an AllocationAsk is created.</li><li>The scheduler processes the AllocationAsk (more detail below) and replaces a placeholder with the real allocation.</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="application-submit-handling"></a>Application submit handling<a aria-hidden="true" tabindex="-1" class="hash-link" href="#application-submit-handling" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="total-placeholder-size"></a>Total placeholder size<a aria-hidden="true" tabindex="-1" class="hash-link" href="#total-placeholder-size" title="Direct link to heading">#</a></h3><p>The application if requesting one or more TaskGroups should provide the total size of all the TaskGroup members it is going to request.
The total resource size is required for the case that the application is scheduled in a queue with a resource limit set.</p><p>The value is important for three cases:</p><ol><li>gang request is larger than the queue quota</li><li>start of scheduling reservations</li><li>resource pressure while scheduling reservations</li></ol><p>Further detail will be given below in <a href="#scheduling-in-queues-with-a-quota-set">scheduling in queues with a quota set</a></p><p>The information passed on from the shim should be part of the AddApplicationRequest.
Detailed information on the build up of the taskGroup(s), or the number of members are not relevant.
The total resource requested by all taskGroup members is calculated using:</p><p><img alt="ask caclulation" src="/assets/images/gang_total_ask-5962332571a96d36894af545be00f2b2.png"></p><p>This total placeholderAsk is added as an optional field to the AddApplicationRequest message.
The calculation can be made by the shim based on the CRD or annotation provided in the pod description.</p><p>If the placeholderAsk is larger than the queue quota set on the queue the application must be rejected.
This rejection is based on the fact that we cannot in any way honor the request.
For all other cases the application is accepted and will be scheduled as per normal.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="handling-queue-with-a-fair-sort-policy"></a>Handling queue with a FAIR sort policy<a aria-hidden="true" tabindex="-1" class="hash-link" href="#handling-queue-with-a-fair-sort-policy" title="Direct link to heading">#</a></h3><p>If an application is submitted to a queue that has a FAIR sort policy set it must be rejected.
Queue sorting for the queue that the application runs in must be set to <em>FIFO</em> or <em>StateAware</em>.</p><p>Other queue policies cannot guarantee that there is only one <em>New</em> application processed at a time.
In the case of the <em>FAIR</em> policy we could be allocating multiple <em>New</em> applications at the same time making quota management impossible to enforce.
The other side effect of using <em>FAIR</em> as a policy could be that we get multiple applications with only a partial allocated guarantee.</p><p>Auto-scaling can be triggered due to the fact that the core can not place the placeholders on any node.
In case the queue would use the <em>FAIR</em> sorting this could lead to other applications taking the scaled up nodes instead of the placeholders again breaking the gang.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="scheduling-in-queues-with-a-quota-set"></a>Scheduling in queues with a quota set<a aria-hidden="true" tabindex="-1" class="hash-link" href="#scheduling-in-queues-with-a-quota-set" title="Direct link to heading">#</a></h2><p>The main case already described above is handling a total placeholder request size that is larger than the quota set on the queue.
When the application is submitted we can already assess that we cannot satisfy that requirement and reject the request.</p><p>In the case that the total placeholder ask does fit in the queue we should not start scheduling until there are enough resources available in the queue to satisfy the total request.
However this does not stop scheduling of other applications in the queue(s).
Applications that are already running in the queue could ask for more resources.
From an application perspective there is no limit set on the resource it can request.
The gang defined on the application is a guaranteed number of resources, not a maximum number of resources the application can request.</p><p>This is complicated by the fact that we have a queue hierarchy.
There is the possibility that the quota is not set directly on the queue the application is running.
It could be set on one of the parent queues.
This case could become complex, and we need to make sure that we keep in mind that we could live lock the scheduling.</p><p>In this first phase we should focus on the case that the gang resources requested are also the maximum number of resources the application will request.
When we look at the queues we should focus on a single queue level with quotas.</p><p>These two assumptions are correct for the spark use case without dynamic allocation using a dynamic mapping from a namespace to a queue.</p><p>Furthermore, we assume that the quota set on the queue can be totally allocated.
If the cluster does not have enough resources the cluster will scale up to the size needed to provide all queues with their full quota.</p><p>The follow up should add further enhancements for deeper hierarchies and dynamic allocation support.
This could also leverage preemption in certain use cases, like preempting allocations from applications over their total gang size.</p><p>Further enhancements could be added by allowing specifying the time and application will wait for the placeholders to be allocated, or the time to start using the held resources.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="scheduler-logic-changes"></a>Scheduler logic changes<a aria-hidden="true" tabindex="-1" class="hash-link" href="#scheduler-logic-changes" title="Direct link to heading">#</a></h2><p>The scheduler logic change needs to account for two parts of cycle:</p><ul><li>The placeholder asks and their allocation.</li><li>The allocation replacing the placeholder.</li></ul><p>The basic assumption is that all pods will generate a placeholder pod request to the core.
This includes the pod that triggered the application creation if we do not use the application CRD.
This assumption is needed to make sure that the scheduler core can behave in the same way for both ways of submitting the application.
The placeholder pods must be communicated to the core before the real pod.</p><p>Changes for the placeholder AllocationAsks are the first step.
As part of the creation of the application the AllocationAsks get added.
The addition of an AllocationsAsk normally will trigger the application state change as per the scheduling cycle.
It moves the Application from a <em>New</em> state to an <em>Accepted</em> state. This is as per the current setup, and does not change.</p><p>However, in the case that the AllocationAsk has the <em>placeholder</em> flag set the allocation should not trigger a state change, the application stays in <em>Accepted</em> state.
AllocationAsks are processed until the application has no pending resources.
AllocationAsks that do not have a <em>placeholder</em> flag set should be ignored as a safety precaution.
All resulting Allocations for the placeholder pods are confirmed to the shim as per the normal steps.
This process continues until there are no more placeholder pods to be allocated.</p><p>The shim at that point should create the AllocationAsk for the real pod(s) that it has buffered.
The core cannot and must not assume that there is only one task group per application.
The core is also not in the position to assume that it has received all AllocationAsks that belong to the task group if option 1 as described above is used by a shim.
This is also why we have the assumption that every pod creates a placeholder request to the core.</p><p>The second change is the replacement of the placeholder pods with the real pods.
The shim creates an AllocationAsk with the <em>taskGroupName</em> set but the <em>placeholder</em> flag is not set.</p><p>The process described here lines up with the process for generic pre-emption.
An allocation is released by the core and then confirmed by the shim.
For gang scheduling we have a simple one new to one release relation in the case of pre-emption we can use the same flow with a one new to multiple release relation.</p><p>The scheduler processes the AllocationAsk as follows:</p><ol><li>Check if the application has an unreleased allocation for a placeholder allocation with the same <em>taskGroupName.</em> If no placeholder allocations are found a normal allocation cycle will be used to allocate the request.</li><li>A placeholder allocation is selected and marked for release. A request to release the placeholder allocation is communicated to the shim. This must be an async process as the shim release process is dependent on the underlying K8s response which might not be instantaneous.<br>NOTE: no allocations are released in the core at this point in time.</li><li>The core “parks” the processing of the real AllocationAsk until the shim has responded with a confirmation that the placeholder allocation has been released.<br>NOTE: locks are released to allow scheduling to continue</li><li>After the confirmation of the release is received from the shim the “parked” AllocationAsk processing is finalised.</li><li>The AllocationAsk is allocated on the same node as the placeholder used.
The removal of the placeholder allocation is finalised in either case. This all needs to happen as one update to the application, queue and node.<ul><li>On success: a new Allocation is created.</li><li>On Failure: try to allocate on a different node, if that fails the AllocationAsk becomes unschedulable triggering scale up. </li></ul></li><li>Communicate the allocation back to the shim (if applicable, based on step 5)</li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="application-completion"></a>Application completion<a aria-hidden="true" tabindex="-1" class="hash-link" href="#application-completion" title="Direct link to heading">#</a></h2><p>Application completion has been a long standing issue.
Currently, applications do not transition to a <em>completed</em> state when done.
The current states for the application are <a href="/docs/next/design/scheduler_object_states">documented here</a>.
However, at this point in time an application will not reach the <em>completed</em> state and will be stuck in <em>waiting</em>.</p><p>This provides a number of issues specifically around memory usage and cleanup of queues in long running deployments.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="definition"></a>Definition<a aria-hidden="true" tabindex="-1" class="hash-link" href="#definition" title="Direct link to heading">#</a></h3><p>Since we cannot rely on the application, running as pods on Kubernetes, to show that it has finished we need to define when we consider an application <em>completed</em>.
At this point we are defining that an application is <em>completed</em> when it has been in the <em>waiting</em> state for a defined time period.
An application enters the waiting state at the time that there are no active allocations (allocated resources &gt; 0) and pending allocation asks (pending resources &gt; 0).</p><p>The transition to a <em>waiting</em> state is already implemented.
The time out of the <em>waiting</em> state is new functionality.</p><p>Placeholders are not considered active allocations.
Placeholder asks are considered pending resource asks.
These cases will be handled in the <a href="#Cleanup">Cleanup</a> below.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="cleanup"></a>Cleanup<a aria-hidden="true" tabindex="-1" class="hash-link" href="#cleanup" title="Direct link to heading">#</a></h3><p>When we look at gang scheduling there is a further issue around unused placeholders, placeholder asks and their cleanup.
Placeholders could be converted into real allocations at any time there are pending allocation asks or active allocations.</p><p>Placeholder asks will all be converted into placeholder allocations before the real allocations are processed.</p><p>Entry into the <em>waiting</em> state is already handled.
If new allocation asks are added to the application it will transition back to a <em>running</em> state.
At the time we entered the waiting state. there were no pending requests or allocated resources.
There could be allocated placeholders.</p><p>For the entry into the <em>waiting</em> state the application must be clean.
However, we can not guarantee that all placeholders will be used by the application during the time the application runs.
Transitioning out of the <em>waiting</em> state into the <em>completed</em> state requires no (placeholder) allocations or asks at all.
The second case that impact transitions is that not all placeholder asks are allocated, and the application thus never requests any real allocations.
These two cases could prevent an application from transitioning out of the <em>accepted</em>, or the <em>waiting</em> state.</p><p>Processing in the core thus needs to consider two cases that will impact the transition out of specific states:</p><ol><li>Placeholder asks pending (exit from <em>accepted</em>)</li><li>Placeholders allocated (exit from <em>waiting</em>)</li></ol><p>Placeholder asks pending:<br>
Pending placeholder asks are handled via a timeout.
An application must only spend a limited time waiting for all placeholders to be allocated.
This timeout is needed because an application’s partial placeholders allocation may occupy cluster resources without really using them.</p><p>An application could be queued for an unknown time, waiting for placeholder allocation to start.
The timeout for placeholder asks can thus not be linked to the creation of the application or the asks.
The timeout must start at the time the first placeholder ask is allocated.</p><p>The application cannot request real allocations until all placeholder asks are allocated.
A placeholder ask is also tracked by the shim as it represents a pod.
Releasing an ask in the core requires a message to flow between the core and shim to release that ask.
However, in this case the timeout for allocating placeholder asks triggers an application failure.
When the timeout is triggered and placeholder asks are pending the application will transition from the state it is in, which can only be <em>accepted</em>, to <em>killed</em>.</p><p>The application state for this case can be summarised as:</p><ul><li>Application status is <em>accepted</em></li><li>Placeholder allocated resource is larger than zero, and less than the <em>placeholderAsk</em> from the <em>AddApplicationRequest</em></li><li>Pending resource asks is larger than zero</li></ul><p>Entering into the <em>killed</em> state must move the application out of the queue automatically.</p><p>The state change and placeholder allocation releases can be handled in a single UpdateResponse message. The message will have the following content:</p><ul><li><em>UpdatedApplication</em> for the state change of the application</li><li>one or more <em>AllocationRelease</em> messages, one for each placeholder, with the  <em>TerminationType</em> set to TIMEOUT</li><li>one or more AllocationAskRelease messages with the <em>TerminationType</em> set to TIMEOUT</li></ul><p>The shim processes the AllocationAskRelease messages first, followed by the <em>AllocationResponse</em> messages, and finally the <em>UpdatedApplication</em> message. The application state change to the <em>killed</em> state on the core side is only dependent on the removal of all placeholders pods, not on a response to the _UpdatedApplication _message.</p><p><img alt="placeholder timeout" src="/assets/images/gang_timeout-2e8b67c25538a8f49f7c059f113ac1b0.png"></p><p>Combined flow for the shim and core during timeout of placeholder:</p><ul><li>The core times out the placeholder allocation. (1)</li><li>The placeholder Allocations removal is passed to the shim. (2)</li><li>All placeholder Allocations are released by the shim, and communicated back to the core.</li><li>The placeholder AllocationAsks removal is passed to the shim. (3)</li><li>All placeholder AllocationAsks are released by the shim, and communicated back to the core.</li><li>After the placeholder Allocations and Asks are released the core moves the application to the killed state removing it from the queue (4).</li><li>The state change is finalised in the core and shim. (5)</li></ul><p>Allocated placeholders:<br>
Leftover placeholders need to be released by the core.
The shim needs to be informed to remove them. This must be triggered on entry of the <em>completed</em> state.
After the placeholder release is requested by the core the state transition of the application can proceed.
The core will process the <em>AllocationRelease</em> messages for placeholder allocations that come back from the shim with the <em>TerminationType</em> set to TIMEOUT as normal without triggering a state change.</p><p>The state change and placeholder allocation releases can be handled in a single UpdateResponse message.
The message will have the following content:</p><ul><li><em>UpdatedApplication</em> for the state change of the application</li><li>zero or more <em>AllocationRelease</em> messages, one for each placeholder, with the  <em>TerminationType</em> set to TIMEOUT</li></ul><p>The shim processes the <em>AllocationResponse</em> messages first followed by the <em>UpdatedApplication</em> message.
The application state change to the <em>completed</em> state on the core side is only dependent on the removal of all placeholders pods, not on a response to the _UpdatedApplication _message.</p><p>Entering into the <em>completed</em> state will move the application out of the queue automatically.
This should also handle the case we discussed earlier around a possible delayed processing of requests from the shim as we can move back from <em>waiting</em> to <em>running</em> if needed.
A <em>completed</em> application should also not prevent the case that was discussed around cron like submissions using the same application ID for each invocation.
A <em>completed</em> application with the same application ID must not prevent the submission of a new application with the same ID.</p><p><img alt="application cleanup flow" src="/assets/images/gang_clean_up-c2019679692548acac0667d84feea985.png"></p><p>Combined flow for the shim and core during cleanup of an application:</p><ul><li>A pod is released at the Kubernetes layer. (1)</li><li>The shim passes the release of the allocation on to the core. (2)</li><li>The core transitions the application to a waiting state if no pending or active allocations. (3)</li><li>The waiting state times out and triggers the cleanup. (4)</li><li>The placeholder Allocations removal is passed to the shim. (5)</li><li>All placeholder Allocations are released by the shim, and communicated back to the core.</li><li>After all placeholders are released the core moves the application to the completed state removing it from the queue (6).</li><li>The state change is finalised in the core and shim. (7)</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="application-recovery"></a>Application recovery<a aria-hidden="true" tabindex="-1" class="hash-link" href="#application-recovery" title="Direct link to heading">#</a></h2><p>During application recovery the placeholder pods are recovered as any other pod on a node.
These pods are communicated to the core by the shim as part of the node as an existing allocation.
Existing allocations do not have a corresponding <em>AllocationAsk</em> in the core. The core generates an <em>AllocationAsk</em> based on the recovered information.</p><p>For gang scheduling the <em>AllocationAsk</em> contains the <em>taskGroupName</em> and <em>placeholder</em> flag.
During recovery that same information must be part of the <em>Allocation</em> message.
This is due to the fact that the same message is used in two directions, from the RM to the scheduler and vice versa means we need to update the message and its processing.</p><p>If the information is missing from the <em>Allocation</em> message the recovered allocation will not be correctly tagged in the core.
The recovered allocation will be seen as a regular allocation.
This means it is skipped as part of the normal allocation cycle that replaces the placeholders.</p><p>The logic change only requires that the recovery of existing allocations copies the fields from the interface message into the allocation object in the core.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="interface-changes"></a>Interface changes<a aria-hidden="true" tabindex="-1" class="hash-link" href="#interface-changes" title="Direct link to heading">#</a></h2><p>Multiple changes are needed to the communication between the shim and the core to support the gang information needed.</p><p>An application must provide the total size of the placeholder requests to prevent accepting an application that can never run.</p><p>The current object that is sent from the shim to the core for allocation requests is defined in the AllocationAsk.
The Allocation, as the result message passed back from the scheduler core does not change. For recovery, which uses the same Allocation message, from the shim to the core, however must contain the gang related fields.
Gang related fields must be added to both messages.</p><p>The allocation release request and response request need to support bidirectional traffic and will need to undergo major changes.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="addapplication"></a>AddApplication<a aria-hidden="true" tabindex="-1" class="hash-link" href="#addapplication" title="Direct link to heading">#</a></h3><p>The AddApplicationRequest message requires a new field to communicate the total placeholder resource request that will be requested.
The field is used to reject the application if it is impossible to satisfy the request.
It can also be used to stop the core from scheduling any real pods for that application until all placeholder pods are processed.</p><p>In patched message form that would look like:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">message AddApplicationRequest {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // The total amount of resources gang placeholders will request</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Resource placeholderAsk = 7;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="allocationask"></a>AllocationAsk<a aria-hidden="true" tabindex="-1" class="hash-link" href="#allocationask" title="Direct link to heading">#</a></h3><p>The first part of the change is the base information for the task group.
This will require an additional optional attribute to be added.
The content of this optional attribute is a name, a string, which will be mapped to the name of the task group.
The field can be present on a real allocation and on a placeholder.</p><p>Proposed name for the new field is: <em>taskGroupName</em></p><p>To distinguish normal AllocationAsks and placeholder AllocationAsks a flag must be added.
The flag will never have more than two values and thus maps to a boolean. As the default value for a boolean is <em>false</em> the field should show the fact that it is an AllocationAsk that represents a placeholder as true.</p><p>Proposed name for the field is: <em>placeholder</em></p><p>In patched message form that would look like:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">message AllocationAsk {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // The name of the TaskGroup this ask belongs to</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  string taskGroupName = 10;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Is this a placeholder ask (true) or a real ask (false), defaults to false</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // ignored if the taskGroupName is not set</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool placeholder = 11;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The last part of the task group information that needs to be communicated is the size of the task group.
This does not require a change in the interface as the current AllocationAsk object can support both possible options.</p><p>Requests can be handled in two ways:</p><ol><li>Each member of the task group is passed to the core as a separate AllocationAsk with a maxAllocations, or the ask repeat, of 1</li><li>The task group is considered one AllocationAsk with a maxAllocations set to the same value as minMember of the task group information.</li></ol><p>With option A the shim will need to generate multiple AllocationAsk objects and pass each to the core for scheduling.
Each AllocationAsk is linked to one pod.
Option B will only generate one AllocationAsk for all placeholder pods.
Option B requires less code and has less overhead on the core side.
However the logic on the shim side might be more complex as the returned allocation needs to be linked to just one pod.</p><p>Proposal is to use option: A</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="allocation"></a>Allocation<a aria-hidden="true" tabindex="-1" class="hash-link" href="#allocation" title="Direct link to heading">#</a></h3><p>Similar to the change for the <em>AllocationAsk</em> the <em>Allocation</em> requires additional optional attributes to be added.
The new fields distinguish a normal Allocation and placeholder Allocations on recovery.
The same rules apply to these fields as the ones added to the <em>AllocationAsk</em>.</p><p>The content of this optional attribute is a name, a string, which will be mapped to the name of the task group.
The field can be present on a real allocation and on a placeholder.</p><p>Proposed name for the new field is: <em>taskGroupName</em></p><p>The flag will never have more than two values and thus maps to a boolean.
As the default value for a boolean is <em>false</em> the field should show the fact that it is an Allocation that represents a placeholder as true.</p><p>Proposed name for the field is: <em>placeholder</em></p><p>In patched message form that would look like:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">message Allocation {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // The name of the TaskGroup this allocation belongs to</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  string taskGroupName = 11;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Is this a placeholder allocation (true) or a real allocation (false), defaults to false</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // ignored if the taskGroupName is not set</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool placeholder = 12;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="allocationrelease-response-and-request"></a>AllocationRelease Response and Request<a aria-hidden="true" tabindex="-1" class="hash-link" href="#allocationrelease-response-and-request" title="Direct link to heading">#</a></h3><p>The name for the messages are based on the fact that the release is always triggered by the shim.
In case of preemption and or gang scheduling the release is not triggered from the shim but from the core.
That means the message name does not cover the usage. A response message might not have an associated request message.
It could be used to indicate direction but that is in this case confusing.</p><p>When a release is triggered from the core, for preemption or the placeholder allocation, a response is expected from the shim to confirm that the release has been processed.
This response must be distinguished from a request to release the allocation initiated by the shim.
A release initiated by the shim must be followed by a confirmation from the core to the shim that the message is processed.
For releases initiated by the core no such confirmation message can or must be sent.
In the current request message there is no way to indicate that it is a confirmation message.</p><p>To fix the possible confusing naming the proposal is to merge the two messages into one message: <em>AllocationRelease</em>.</p><p>The <em>AllocationReleaseRequest</em> is indirectly part of the <em>UpdateRequest</em> message as it is contained in the <em>AllocationReleasesRequest</em>.
The <em>AllocationReleaseResponse</em> is part of the <em>UpdateResponse</em> message.
The flow-on effect of the rename and merge of the two messages is a change in the two messages that contain them.
The message changes for <em>UpdateResponse</em> and <em>AllocationReleasesRequest</em> are limited to type changes of the existing fields.</p><table><thead><tr><th>Message</th><th>Field ID</th><th>Old type</th><th>New type</th></tr></thead><tbody><tr><td>UpdateResponse</td><td>3</td><td>AllocationReleaseResponse</td><td>AllocationRelease</td></tr><tr><td>AllocationReleasesRequest</td><td>1</td><td>AllocationReleaseRequest</td><td>AllocationRelease</td></tr></tbody></table><p>In patched message form that would look like:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">message UpdateResponse {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Released allocation(s), allocations can be released by either the RM or scheduler.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // The TerminationType defines which side needs to act and process the message. </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  repeated AllocationRelease releasedAllocations = 3;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">message AllocationReleasesRequest {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Released allocation(s), allocations can be released by either the RM or scheduler.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // The TerminationType defines which side needs to act and process the message. </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  repeated AllocationRelease releasedAllocations = 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>The merged message <em>AllocationRelease</em> will consist of:</p><table><thead><tr><th>Field name</th><th>Content type</th><th>Required</th></tr></thead><tbody><tr><td>partitionName</td><td>string</td><td>yes</td></tr><tr><td>applicationID</td><td>string</td><td>no</td></tr><tr><td>UUID</td><td>string</td><td>no</td></tr><tr><td>terminationType</td><td><em>TerminationType</em></td><td>yes</td></tr><tr><td>message</td><td>string</td><td>no</td></tr></tbody></table><p>Confirmation behaviour of the action should be triggered on the type of termination received.
The core will confirm the release to the shim of all types that originate in the shim and vice versa.</p><p>A confirmation or response uses the same <em>TerminationType</em> as was set in the original message.
An example of this is a pod that is removed from K8s will trigger an <em>AllocationRelease _message to be sent from the shim to the core with the TerminationType STOPPED_BY_RM. The core processes the request removing the allocation from the internal structures, and when all processing is done it responds to the shim with a message using the same _TerminationType</em>.
The shim can ignore that or make follow up changes if needed.</p><p>A similar process happens for a release that originates in the core.
Example of the core sending an <em>AllocationRelease</em> message to the shim using the <em>TerminationType</em> PREEMPTED_BY_SCHEDULER.
The shim handles that by releasing the pod identified and responds to the core that it has released the pod.
On receiving the confirmation that the pod has been released the core can progress with the allocation and preemption processing.</p><p>In patched message form that would look like:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">message AllocationRelease {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  enum TerminationType {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    STOPPED_BY_RM = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    TIMEOUT = 1; </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    PREEMPTED_BY_SCHEDULER = 2;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    PLACEHOLDER_REPLACED = 3;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // The name of the partition the allocation belongs to</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  string partitionName = 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // The application the allocation belongs to</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  string applicationID = 2;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // The UUID of the allocation to release, if not set all allocations are released for</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // the applicationID</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  string UUID = 3;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // The termination type as described above </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  TerminationType terminationType = 4;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // human-readable message</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  string message = 5;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="terminationtype"></a>TerminationType<a aria-hidden="true" tabindex="-1" class="hash-link" href="#terminationtype" title="Direct link to heading">#</a></h3><p>The currently defined <em>TerminationType</em> values and specification of the side that generates (Sender), and the side that actions and confirms processing (Receiver):</p><table><thead><tr><th>Value</th><th>Sender</th><th>Receiver</th></tr></thead><tbody><tr><td>STOPPED_BY_RM</td><td>shim</td><td>core</td></tr><tr><td>TIMEOUT *</td><td>core</td><td>shim</td></tr><tr><td>PREEMPTED_BY_SCHEDULER *</td><td>core</td><td>shim</td></tr></tbody></table><ul><li>currently not handled by the shim, core or both</li></ul><p>When the placeholder allocation gets released the <em>AllocationReleaseResponse</em> is used to communicate the release back from the core to the shim.
The response contains an enumeration called <em>TerminationType</em>, and a human-readable message.
For tracking and tracing purposes we should add a new <em>TerminationType</em> specifically for the placeholder replacement. The shim must take action based on the type and confirm the allocation release to the core.</p><p>It should provide enough detail so we do not have to re-use an already existing type, or the human-readable message.
The human-readable format can still be used to provide further detail on which new allocation replaced the placeholder.</p><p>Proposal is to add: <em>PLACEHOLDER_REPLACED</em></p><table><thead><tr><th>Value</th><th>Sender</th><th>Receiver</th></tr></thead><tbody><tr><td>PLACEHOLDER_REPLACED</td><td>shim</td><td>core</td></tr></tbody></table><p>As part of the Scheduler Interface cleanup (<a href="https://issues.apache.org/jira/browse/YUNIKORN-486" target="_blank" rel="noopener noreferrer">YUNIKORN-486</a>) the <em>TerminationType</em> should be extracted from the <em>AllocationRelease</em> and <em>AllocationaskRelease</em> message.
It is an enumeration that can be shared between multiple objects.
<a href="https://issues.apache.org/jira/browse/YUNIKORN-547" target="_blank" rel="noopener noreferrer">YUNIKORN-547</a> has been logged to handle this as it has an impact on the code outside of the scope of gang scheduling.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="allocationaskrelease-response-and-request"></a>AllocationAskRelease Response and Request<a aria-hidden="true" tabindex="-1" class="hash-link" href="#allocationaskrelease-response-and-request" title="Direct link to heading">#</a></h3><p>The allocation ask release right now can only be triggered by the shim.
In order for the core to perform the cleanup when the placeholder allocation times out, we need to make this a bidirectional message.
Similarly to the Allocation we would rename the <em>AllocationAskReleaseRequest</em> to <em>AllocationAskRelease</em>, so we can use this message in both directions:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">message AllocationReleasesRequest {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Released allocationask(s), allocationasks can be released by either the RM or</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // scheduler. The TerminationType defines which side needs to act and process the</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // message. </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  repeated AllocationAskRelease allocationAsksToRelease = 2;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Similar processing logic based on the <em>TerminationType</em> which is used for allocations should be used for ask releases.
In patched message form that would look like:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">message AllocationAskRelease {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  enum TerminationType {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    STOPPED_BY_RM = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    TIMEOUT = 1; </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    PREEMPTED_BY_SCHEDULER = 2;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    PLACEHOLDER_REPLACED = 3;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // The termination type as described above </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  TerminationType terminationType = 4;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><p>Confirmation behaviour of the action should be triggered on the type of termination received.
The core will confirm the release to the shim of all types that originate in the shim and vice versa.</p><p>A confirmation or response uses the same <em>TerminationType</em> as was set in the original message.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="scheduler-storage-object-changes"></a>Scheduler storage object changes<a aria-hidden="true" tabindex="-1" class="hash-link" href="#scheduler-storage-object-changes" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="allocationask-1"></a>AllocationAsk<a aria-hidden="true" tabindex="-1" class="hash-link" href="#allocationask-1" title="Direct link to heading">#</a></h3><p>In line with the changes for the communication the objects in the scheduler also need to be modified to persist some of the detail communicated.
The AllocationAsk that is used in the communication has an equivalent object inside the scheduler with the same name.
This object needs to be able to store the new fields proposed above.</p><p>Proposed new fields: <em>taskGroupName</em> and <em>placeholder</em>.</p><p>In the current interface specification a field called <em>executionTimeoutMilliSeconds</em> is defined.
This is currently not mapped to the object inside the scheduler and should be added.
Time or Duration are stored as native go objects and do not include a size specifier.</p><p>Proposed new field: <em>execTimeout</em></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="allocation-1"></a>Allocation<a aria-hidden="true" tabindex="-1" class="hash-link" href="#allocation-1" title="Direct link to heading">#</a></h3><p>After the allocation is made an Allocation object is created in the core to track the real allocation. This Allocation object is directly linked to the application and should show that the allocation is a placeholder and for which task group. This detail is needed to also enable the correct display of the resources used in the web UI.</p><p>The propagation of the placeholder information could be achieved indirectly as the allocation object references an AllocationAsk. This would require a lookup of the AllocationAsk to assess the type of allocation. We could also opt to propagate the data into the Allocation object itself. This would remove the lookup and allow us to directly filter allocations based on the type and or task group information.</p><p>From a scheduling and scheduler logic perspective the indirect reference is not really desirable due to the overhead of the lookups required. This means that the same fields added in the AllocationAsk are also added to the Allocation object.</p><p>Proposed new fields: <em>taskGroupName</em> and <em>placeholder</em>.</p><p>To support the release of the allocation being triggered from the core tracking of the release action is required. The release is not final until the shim has confirmed that release. However during that time period the allocation may not be released again.</p><p>Proposed new field: <em>released</em></p><p>At the point that we replace the placeholder with a real allocation we need to release an existing placeholder.
The Allocation object allows us to specify a list of Allocations to release.
This field was added earlier to support preemption.
This same field will be reused for the placeholder release.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="application"></a>Application<a aria-hidden="true" tabindex="-1" class="hash-link" href="#application" title="Direct link to heading">#</a></h3><p>The AddApplicationRequest has a new field added that needs to be persisted in the object inside the scheduler.</p><p>Proposed new field: <em>placeholderAsk</em></p><p>In the current interface specification a field called <em>executionTimeoutMilliSeconds</em> is defined. This is currently not mapped to the object inside the scheduler and should be added. Time or Duration are stored as native go objects and do not include a size specifier.</p><p>Proposed new field: <em>execTimeout</em></p><p>The application object should be able to track the placeholder allocations separately from the real allocations. The split of the allocation types on the application will allow us to show the proper state in the web UI.</p><p>Proposed new field: <em>allocatedPlaceholder</em></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="queue--node"></a>Queue &amp; Node<a aria-hidden="true" tabindex="-1" class="hash-link" href="#queue--node" title="Direct link to heading">#</a></h3><p>No changes at this point.
The placeholder allocations should be counted as “real” allocations on the Queue and Node.
By counting the placeholder as normal the quota for the queue is enforced as expected.
The Node object needs to also show normal usage to prevent interactions with the autoscaler.</p></div></article><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/next/design/scheduler_object_states"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« Scheduler Object States</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/next/performance/evaluate_perf_function_with_kubemark"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Evaluate YuniKorn function &amp; performance with Kubemark »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_3SO_"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#document-goals" class="table-of-contents__link">Document goals</a></li><li><a href="#excluded-design-points" class="table-of-contents__link">Excluded design points</a></li><li><a href="#generic-flow" class="table-of-contents__link">Generic flow</a></li><li><a href="#application-submit-handling" class="table-of-contents__link">Application submit handling</a><ul><li><a href="#total-placeholder-size" class="table-of-contents__link">Total placeholder size</a></li><li><a href="#handling-queue-with-a-fair-sort-policy" class="table-of-contents__link">Handling queue with a FAIR sort policy</a></li></ul></li><li><a href="#scheduling-in-queues-with-a-quota-set" class="table-of-contents__link">Scheduling in queues with a quota set</a></li><li><a href="#scheduler-logic-changes" class="table-of-contents__link">Scheduler logic changes</a></li><li><a href="#application-completion" class="table-of-contents__link">Application completion</a><ul><li><a href="#definition" class="table-of-contents__link">Definition</a></li><li><a href="#cleanup" class="table-of-contents__link">Cleanup</a></li></ul></li><li><a href="#application-recovery" class="table-of-contents__link">Application recovery</a></li><li><a href="#interface-changes" class="table-of-contents__link">Interface changes</a><ul><li><a href="#addapplication" class="table-of-contents__link">AddApplication</a></li><li><a href="#allocationask" class="table-of-contents__link">AllocationAsk</a></li><li><a href="#allocation" class="table-of-contents__link">Allocation</a></li><li><a href="#allocationrelease-response-and-request" class="table-of-contents__link">AllocationRelease Response and Request</a></li><li><a href="#terminationtype" class="table-of-contents__link">TerminationType</a></li><li><a href="#allocationaskrelease-response-and-request" class="table-of-contents__link">AllocationAskRelease Response and Request</a></li></ul></li><li><a href="#scheduler-storage-object-changes" class="table-of-contents__link">Scheduler storage object changes</a><ul><li><a href="#allocationask-1" class="table-of-contents__link">AllocationAsk</a></li><li><a href="#allocation-1" class="table-of-contents__link">Allocation</a></li><li><a href="#application" class="table-of-contents__link">Application</a></li><li><a href="#queue--node" class="table-of-contents__link">Queue &amp; Node</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Blog</h4><ul class="footer__items"><li class="footer__item"><a href="https://blog.cloudera.com/yunikorn-a-universal-resources-scheduler/" target="_blank" rel="noopener noreferrer" class="footer__link-item">What&#x27;s YuniKorn?</a></li><li class="footer__item"><a href="https://blog.cloudera.com/apache-yunikorn-incubating-0-8-release-whats-new-and-upcoming/" target="_blank" rel="noopener noreferrer" class="footer__link-item">What&#x27;s new in YuniKorn 0.8.0?</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Github</h4><ul class="footer__items"><li class="footer__item"><a href="https://github.com/apache/incubator-yunikorn-core/" target="_blank" rel="noopener noreferrer" class="footer__link-item">scheduler-core</a></li><li class="footer__item"><a href="https://github.com/apache/incubator-yunikorn-k8shim" target="_blank" rel="noopener noreferrer" class="footer__link-item">kubernetes-shim</a></li><li class="footer__item"><a href="https://github.com/apache/incubator-yunikorn-scheduler-interface" target="_blank" rel="noopener noreferrer" class="footer__link-item">scheduler-interface</a></li><li class="footer__item"><a href="https://github.com/apache/incubator-yunikorn-web" target="_blank" rel="noopener noreferrer" class="footer__link-item">scheduler-web</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/community/get_involved">Get Involved</a></li><li class="footer__item"><a href="http://people.apache.org/phonebook.html?podling=yunikorn" target="_blank" rel="noopener noreferrer" class="footer__link-item">Roster</a></li><li class="footer__item"><a href="https://issues.apache.org/jira/projects/YUNIKORN/issues" target="_blank" rel="noopener noreferrer" class="footer__link-item">Issues</a></li></ul></div></div><div class="text--center"><div class="margin-bottom--sm"><a href="https://incubator.apache.org/" target="_blank" rel="noopener noreferrer" class="footerLogoLink_1zJy"><img class="footer__logo" alt="Apache Incubator Logo" src="https://incubator.apache.org/images/incubator_feather_egg_logo.png"></a></div><div>
Copyright © 2021 <a href="http://www.apache.org/">The Apache Software Foundation</a>. Licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a>. <br>
<div style="padding:20px; margin: 10px; color: #4d4d4d;">
  Apache YuniKorn is an effort undergoing incubation at The Apache Software Foundation (ASF), sponsored by the name of Apache TLP sponsor.
  Incubation is required of all newly accepted projects until a further review indicates that the infrastructure, communications,
  and decision making process have stabilized in a manner consistent with other successful ASF projects. While incubation status is not necessarily
  a reflection of the completeness or stability of the code, it does indicate that the project has yet to be fully endorsed by the ASF.
</div>
</div></div></div></footer></div>
<script src="/styles.42927ee7.js"></script>
<script src="/runtime~main.1daa9f04.js"></script>
<script src="/main.6222ead5.js"></script>
<script src="/1.f2f38753.js"></script>
<script src="/2.05510059.js"></script>
<script src="/3.a37a1908.js"></script>
<script src="/1be78505.e1f44db4.js"></script>
<script src="/146.37105179.js"></script>
<script src="/935f2afb.0d861f82.js"></script>
<script src="/17896441.6af894f7.js"></script>
<script src="/4356428f.e37edb5c.js"></script>
</body>
</html>